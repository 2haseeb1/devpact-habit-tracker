অবশ্যই! চলুন, আপনার সম্পূর্ণ এবং চূড়ান্তভাবে সংশোধিত "Habit Tracker" অ্যাপ্লিকেশনের কার্যকারিতা বা ফ্লো Step-back prompting ব্যবহার করে প্রথম থেকে শেষ পর্যন্ত বিস্তারিতভাবে বুঝি।

এই ফ্লো-টি আপনার `auth.config.ts`, `middleware.ts`, `lib/auth.ts`, এবং আপনার UI কম্পোনেন্টগুলোর সম্মিলিত কার্যকারিতার ওপর ভিত্তি করে তৈরি।

### **Step-back প্রশ্ন: একজন নতুন ব্যবহারকারী যখন প্রথমবার আপনার অ্যাপ্লিকেশনে (`devpact-habit-tracker.vercel.app`) আসবে, তখন সে কী দেখবে এবং তার যাত্রা কীভাবে শুরু হবে?**

---
#### **ফ্লো ১: নতুন ব্যবহারকারীর প্রথম ভিজিট এবং লগইন**

**Step 1: Landing Page (হোমপেজ)**
-   **ব্যবহারকারী:** ব্রাউজারে `devpact-habit-tracker.vercel.app` টাইপ করে।
-   **Next.js ও Middleware:**
    -   একটি অনুরোধ (`request`) `/`-এর জন্য আসে।
    -   `middleware.ts` তার `matcher` (`/((?!api...).*)`) দিয়ে চেক করে এবং দেখে যে `/` একটি সুরক্ষিত রুটের তালিকায় নেই (আপনার `authorized` কলব্যাকে)।
    -   `authorized` কলব্যাক `true` রিটার্ন করে। Middleware অনুরোধটিকে যেতে দেয়।
-   **UI:** ব্যবহারকারী `app/page.tsx`-এর ল্যান্ডিং পেজটি দেখে। সেখানে "Commit. Track. Achieve." লেখা এবং একটি "Sign In with GitHub" বাটন রয়েছে। সে এখন লগইন করা নেই।

**Step 2: Sign-In Process (সাইন-ইন প্রক্রিয়া)**
-   **ব্যবহারকারী:** "Sign In with GitHub" বাটনে ক্লিক করে।
-   **Server Action:** `Navbar.tsx`-এর ভেতরের `<form action={signIn...}>` ট্রিগার হয় এবং `signIn('github')` সার্ভার অ্যাকশনটি কল করা হয়।
-   **Auth.js:**
    -   Auth.js একটি `POST` অনুরোধ `/api/auth/signin/github`-এ পাঠায়।
    -   ব্যবহারকারীকে GitHub-এর অথেন্টিকেশন পেজে রিডাইরেক্ট করা হয়।
-   **GitHub:** ব্যবহারকারী GitHub-এ লগইন করে এবং আপনার অ্যাপ্লিকেশনকে পারমিশন দেয়।

**Step 3: Callback এবং সেশন তৈরি**
-   **GitHub:** ব্যবহারকারীকে `code` সহ আপনার অ্যাপ্লিকেশনের callback URL-এ (`.../api/auth/callback/github`) ফেরত পাঠায়।
-   **Auth.js (`lib/auth.ts`):**
    -   `/api/auth/[...nextauth]` রুটের `handler` এই অনুরোধটি গ্রহণ করে।
    -   এটি GitHub-এর সাথে যোগাযোগ করে `code`-এর বিনিময়ে একটি `access_token` নেয়।
    -   সেই টোকেন ব্যবহার করে GitHub থেকে ব্যবহারকারীর প্রোফাইল ডেটা নিয়ে আসে।
    -   আপনার কাস্টম `profile()` ফাংশনটি সেই ডেটাকে একটি স্ট্যান্ডার্ড User অবজেক্টে পরিণত করে।
    -   `PrismaAdapter` ডেটাবেসে `User` এবং `Account` টেবিল চেক করে। যদি ইউজার নতুন হয়, তাহলে তাকে তৈরি করে; পুরনো হলে আপডেট করে।
    -   `session: { strategy: 'jwt' }` অনুযায়ী, এটি একটি এনক্রিপ্টেড JWT (JSON Web Token) তৈরি করে।
    -   `jwt` কলব্যাকটি চলে এবং টোকেনের ভেতরে `id` ও `username` যোগ করে।
    -   এই JWT-টি ব্রাউজারে একটি সুরক্ষিত, http-only কুকি হিসেবে সেট করা হয়।
-   **রিডাইরেকশন:** Auth.js সফলভাবে সেশন তৈরি করার পর ব্যবহারকারীকে `/dashboard`-এ রিডাইরেক্ট করে।

---
### **ফ্লো ২: লগইন করা ব্যবহারকারীর যাত্রা**

**Step 4: Accessing the Dashboard (ড্যাশবোর্ড অ্যাক্সেস)**
-   **ব্রাউজার:** `/dashboard`-এর জন্য একটি নতুন অনুরোধ পাঠায়।
-   **Middleware (`middleware.ts`):**
    -   `matcher` দেখে যে `/dashboard` একটি সুরক্ষিত রুট। Middleware চলে।
    -   `auth.config.ts`-এর `authorized` কলব্যাকটি ট্রিগার হয়।
    -   `authorized` ফাংশনটি ব্রাউজার থেকে আসা JWT কুকিটি ডিক্রিপ্ট করে `auth` অবজেক্ট তৈরি করে। যেহেতু ব্যবহারকারী লগইন করা, তাই `auth.user` অবজেক্টটি পাওয়া যায় এবং `isLoggedIn` হয় `true`।
    -   ফাংশনটি `true` রিটার্ন করে এবং middleware অনুরোধটিকে যেতে দেয়।
-   **UI:** ব্যবহারকারী `app/(app)/dashboard/page.tsx` পেজটি দেখতে পায়। `auth()` হেল্পার ব্যবহার করে পেজটি ডেটাবেস থেকে তার ব্যক্তিগত অভ্যাসগুলো নিয়ে আসে এবং `HabitCard` দিয়ে সেগুলো দেখায়।

**Step 5: Creating a New Habit (নতুন অভ্যাস তৈরি)**
-   **ব্যবহারকারী:** "Add New Habit" বাটনে ক্লিক করে `/habits/new` পেজে যায়।
-   **UI:** `app/(app)/habits/new/page.tsx`-এর ফর্মটি দেখানো হয়।
-   **ব্যবহারকারী:** ফর্ম পূরণ করে "Create Habit" বাটনে ক্লিক করে।
-   **Server Action:** `createHabit` সার্ভার অ্যাকশনটি চলে।
    -   এটি `auth()` ব্যবহার করে নিশ্চিত করে যে ব্যবহারকারী লগইন করা আছে।
    -   এটি ফর্মের ডেটা ভ্যালিডেট করে।
    -   `prisma.habit.create` ব্যবহার করে ডেটাবেসে নতুন অভ্যাসটি সেভ করে।
    -   `revalidatePath('/dashboard')` কল করে ড্যাশবোর্ডের ক্যাশ পরিষ্কার করে।
    -   `redirect('/dashboard')` ব্যবহার করে ব্যবহারকারীকে ড্যাশবোর্ডে ফেরত পাঠায়।
-   **UI:** ব্যবহারকারীকে ড্যাশবোর্ডে ফেরত নিয়ে যাওয়া হয় এবং সে সঙ্গে সঙ্গে তার নতুন তৈরি করা অভ্যাসটি দেখতে পায়।

**Step 6: Interacting with the Feed (ফিডের সাথে ইন্টারেকশন)**
-   **ব্যবহারকারী:** `/feed` পেজে যায়।
-   **UI (`app/(app)/feed/page.tsx`):**
    -   পেজটি `prisma.habit.findMany({ where: { isPublic: true } })` ব্যবহার করে সব পাবলিক অভ্যাস নিয়ে আসে।
    -   `auth()` ব্যবহার করে বর্তমান ব্যবহারকারীর `id` নেওয়া হয়, যাতে বোঝা যায় সে কোনো অভ্যাসে 이미 kudo দিয়েছে কি না।
    -   ব্যবহারকারী অন্য কারো অভ্যাসের পাশে থাকা `KudoButton`-এ ক্লিক করে।
-   **Client Component (`KudoButton.tsx`):**
    -   Optimistic UI: সঙ্গে সঙ্গে kudo সংখ্যা বাড়িয়ে দেয় এবং বাটনের স্টাইল পরিবর্তন করে।
    -   ব্যাকগ্রাউন্ডে, এটি `toggleKudo` সার্ভার অ্যাকশনটি কল করে।
-   **Server Action (`lib/actions/kudo.actions.ts`):**
    -   `auth()` ব্যবহার করে ব্যবহারকারীকে ভেরিফাই করে।
    -   ডেটাবেসে `Kudo` এন্ট্রি তৈরি বা ডিলিট করে।
    -   `revalidatePath('/feed')` কল করে, যাতে পেজটি রিফ্রেশ করলে সঠিক ডেটা দেখা যায়।

**Step 7: Sign Out (সাইন আউট)**
-   **ব্যবহারকারী:** `UserNav` ড্রপডাউন থেকে "Sign Out" বাটনে ক্লিক করে।
-   **Server Action (`lib/actions/auth.actions.ts`):**
    -   `<form action={signOut}>`-এর মাধ্যমে `signOut` অ্যাকশনটি কল করা হয়।
    -   Auth.js কুকিটি ডিলিট করে এবং সেশনটি নষ্ট করে দেয়।
    -   ব্যবহারকারীকে `/` (হোমপেজ)-এ রিডাইরেক্ট করে।
-   **UI:** ব্যবহারকারীকে হোমপেজে নিয়ে যাওয়া হয়, যেখানে সে আবার "Sign In with GitHub" বাটনটি দেখতে পায়।

এই সম্পূর্ণ ফ্লো-টি আপনার অ্যাপ্লিকেশনের মূল ভিত্তি এবং এটি প্রমাণ করে যে আপনার সেটআপটি এখন একটি আধুনিক, সুরক্ষিত এবং কার্যকরী Full-Stack অ্যাপ্লিকেশনের জন্য প্রস্তুত।